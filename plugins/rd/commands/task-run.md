---
description: Analyze a task, design a solution blueprint, and create a detailed implementation plan.
---

# task-run

Transform a raw task description into a structured blueprint with a concrete implementation plan.

**Note:** This command works with task files created by `tasks create <name>` and follows the template structure defined in `docs/prompts/.template.md`.

## Purpose

This command provides a systematic approach to task execution:

1. **Task Analysis & Refinement** - Parse, validate, and improve the task definition
2. **Solution Design** - Create a precise, concise solution blueprint
3. **Implementation Planning** - Generate a step-by-step execution plan

The output is written back to the task file, creating a self-documenting artifact that serves as the single source of truth for the task.

## Usage

```bash
# Run with a task file
/rd:task-run <task-file.md>

# Run with analysis only (no modifications)
/rd:task-run <task-file.md> --dry-run

# Skip discovery interview phase (for well-defined tasks)
/rd:task-run <task-file.md> --no-interview

# Skip task refinement phase
/rd:task-run <task-file.md> --no-refine

# Specify planning scope
/rd:task-run <task-file.md> --scope <minimal|standard|comprehensive>

# Fast mode: skip both interview and refinement
/rd:task-run <task-file.md> --no-interview --no-refine
```

## Arguments

- `<task-file.md>` (required): Path to the task file to process
  - Can be relative: `docs/prompts/0001_feature_auth.md`
  - Can be absolute: `/Users/robin/projects/cc-agents/docs/prompts/0001_feature_auth.md`
  - Files are typically created via `tasks create <name>` command

## Options

- `--dry-run`: Analyze and display output without modifying the file
- `--no-interview`: Skip requirements discovery interview (use when requirements are already well-defined)
- `--no-refine`: Skip task refinement, use as-is
- `--scope <level>`: Planning depth (default: standard)
- `--plan-only`: Skip solution design, only create implementation plan

## Task File Format

### Input Format (from `tasks create`)

Task files generated by `prompts.sh` follow this structure:

```markdown
---
name: Add User Authentication
description: Implement JWT-based authentication for REST API
status: Backlog
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 10:30:00
---

## Add User Authentication

### Background

[Context, why this task exists, current situation]

### Requirements / Objectives

[What needs to be accomplished]

### Solutions / Goals

[Leave empty - will be populated by task-run]

### References

[Related docs, links, dependencies]
```

### Output Format

After execution, the file is updated with populated sections:

```markdown
---
name: Add User Authentication
description: Implement JWT-based authentication for REST API
status: WIP
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 12:45:00
---

## Add User Authentication

### Background

[Context information - may be refined]

### Requirements / Objectives

[Requirements - may be refined and expanded]

### Solutions / Goals

### Architecture Overview

...

### Core Components

...

### Data Model

...

### API / Interface Design

...

### Key Implementation Details

...

### Edge Cases Handled

...

### Implementation Plan

### Phase 1: Foundation [Complexity: Low]

...
```

### Updating Status

The command also updates the YAML frontmatter:

- `status`: Changes to `WIP` when planning begins
- `updated_at`: Updates to current timestamp
- `description`: May be refined for clarity

## Workflow

### Phase 1: Load & Validate

```
Reading task file: docs/prompts/0001_feature_auth.md
Parsing YAML frontmatter...
Validating required sections...
```

**Validation Checks:**

- [ ] File exists (use `tasks create <name>` if not)
- [ ] Valid YAML frontmatter (name, status, created_at, updated_at)
- [ ] Required sections present (Background, Requirements / Objectives)
- [ ] No conflicting requirements

**If validation fails:**

- Suggest using `tasks create <name>` for new tasks
- Prompt for missing information
- Ask user to confirm before proceeding

### Phase 2: Requirements Discovery Interview (unless `--no-interview`)

```
Starting requirements discovery...
Analyzing gaps in task definition...
Preparing targeted questions...
```

**Purpose:** Uncover hidden requirements, implicit assumptions, and decision points through structured interviewing before design begins.

**Interview Framework:**

Use `AskUserQuestion` tool with targeted, non-obvious questions. Each interview round should explore 1-4 related questions. Continue iteratively until requirements are sufficiently clear.

**Question Categories (in priority order):**

#### 1. Jobs-to-be-Done (JTBD) - Understand the "Why"

Focus on the underlying motivation, not just the feature request:

- "What situation or event triggered this task? What problem became urgent?"
- "What are you trying to achieve beyond this immediate task?"
- "What does success look like? How will you measure it?"
- "What workarounds exist today? What's painful about them?"

#### 2. Constraints & Non-Functional Requirements

Uncover hidden technical and business constraints:

- "Are there performance requirements (response time, throughput, scale)?"
- "What security or compliance requirements apply?"
- "Are there existing systems, APIs, or patterns this must integrate with?"
- "What's the deployment environment (cloud, on-prem, edge)?"
- "Are there backward compatibility requirements?"

#### 3. Scope Boundaries

Prevent scope creep by defining what's explicitly out:

- "What should this explicitly NOT do?"
- "Are there related features we should defer to a later phase?"
- "What's the MVP vs. the full vision?"
- "What edge cases are acceptable to ignore for now?"

#### 4. User Experience & Workflows

For features with user-facing components:

- "Who are the primary users? Any secondary personas?"
- "Walk me through the ideal user flow step-by-step"
- "What existing UI patterns should this follow?"
- "Are there accessibility requirements?"

#### 5. Data & State

Clarify data ownership and persistence:

- "What data entities are involved? What's their lifecycle?"
- "Where does data come from? Where does it go?"
- "What happens on failure? Is retry/recovery needed?"
- "Are there data migration requirements?"

#### 6. Trade-off Decisions

Surface architectural decisions that need stakeholder input:

- "Speed vs. quality: Is this exploratory or production-critical?"
- "Build vs. buy: Are there existing libraries/services to consider?"
- "Simplicity vs. flexibility: Hardcode or make configurable?"
- "Consistency vs. availability: What's acceptable during failures?"

**Interview Best Practices:**

1. **Ask "how" and "what", not "why"** - Gets more concrete, actionable answers
2. **One topic per question round** - Avoid overwhelming with unrelated questions
3. **Use concrete scenarios** - "If X happens, what should occur?" beats abstract questions
4. **Probe deeper on vague answers** - "Can you give a specific example?" or "What would that look like?"
5. **Validate assumptions explicitly** - "I'm assuming X. Is that correct?"
6. **Know when to stop** - End when answers start repeating or user indicates clarity

**Completion Criteria:**

The interview phase is complete when:

- [ ] Core job-to-be-done is understood (not just feature request)
- [ ] Key constraints are documented
- [ ] Scope boundaries are defined (what's in/out)
- [ ] Major trade-off decisions are made
- [ ] No critical "it depends" answers remain

**Example Interview Flow:**

```
Round 1 (JTBD):
Q: "What situation triggered this task? What problem became urgent?"
A: "Users are complaining about slow search..."

Round 2 (Constraints):
Q: "What's the acceptable search latency? How many concurrent users?"
A: "Under 200ms, peak 1000 users..."

Round 3 (Scope):
Q: "Should search include fuzzy matching, or exact match only for MVP?"
A: "Exact match for MVP, fuzzy later..."

Round 4 (Trade-offs):
Q: "For the search index, prefer real-time updates or batch with delay?"
A: "Batch is fine, up to 5 min delay acceptable..."

→ Interview complete. Proceeding to analysis.
```

**Output:**

After the interview, summarize findings in a structured format that feeds into Phase 3:

```markdown
## Interview Summary

### Core Job
[What the user is ultimately trying to achieve]

### Key Constraints
- [Constraint 1]
- [Constraint 2]

### Scope Decisions
- In scope: [...]
- Out of scope: [...]

### Trade-off Decisions
- [Decision 1]: [Choice made and rationale]

### Open Questions (for Phase 3)
- [Any remaining ambiguities to resolve during analysis]
```

### Phase 3: Analyze & Refine (unless `--no-refine`)

```
Analyzing task requirements...
Identifying ambiguities...
Checking for edge cases...
```

**Refinement Actions:**

- Clarify vague requirements
- Identify implicit assumptions
- Detect missing acceptance criteria
- Spot potential scope creep
- Suggest constraint additions
- May update `description` in frontmatter for clarity

**Example refinement:**

```
BEFORE: "Add authentication to the API"

AFTER: "Add JWT-based authentication to REST API endpoints:
- POST /auth/login - returns JWT token
- POST /auth/register - creates user, returns token
- Protected endpoints require valid JWT in Authorization header
- Token expires after 24 hours
- Refresh token endpoint for renewal"
```

### Phase 4: Design Solution Blueprint

```
Designing solution architecture...
Identifying key components...
Defining integration points...
```

**Solution Design Principles:**

1. **Precise** - Specific technologies, patterns, and approaches
2. **Concise** - Essential details only, no fluff
3. **Actionable** - Clear enough to implement from
4. **Complete** - Covers all requirements and edge cases

**Solution Blueprint Structure (populates `### Solutions / Goals`):**

```markdown
### Solutions / Goals

#### Architecture Overview

[High-level design: components, data flow, key decisions]

#### Core Components

- **Component 1**: [Purpose, tech choice, key interfaces]
- **Component 2**: [Purpose, tech choice, key interfaces]

#### Data Model

[Entities, relationships, validation rules]

#### API / Interface Design

[Endpoints, methods, request/response formats]

#### Key Implementation Details

- [Design pattern to use]
- [Critical algorithm or approach]
- [Error handling strategy]
- [Security considerations]

#### Edge Cases Handled

- [Edge case 1]: [Solution approach]
- [Edge case 2]: [Solution approach]

#### Implementation Plan

[Continues below...]
```

### Phase 5: Create Implementation Plan

```
Breaking down into phases...
Sequencing dependent steps...
Estimating complexity...
```

**Planning Levels:**

**Minimal** (for quick tasks):

- 2-3 phases
- Direct steps
- Focus on core functionality

**Standard** (default):

- 4-6 phases
- Includes testing and documentation
- Balances speed and quality

**Comprehensive** (for complex features):

- 6+ phases
- Includes rollout, monitoring, rollback
- Production-ready approach

**Implementation Plan Structure (appended to `### Solutions / Goals`):**

```markdown
#### Implementation Plan

##### Phase 1: Foundation [Complexity: Low]

**Goal**: [What this phase achieves]

- [ ] [Specific action item]
- [ ] [Specific action item]
      **Deliverable**: [Tangible outcome]

##### Phase 2: Core Implementation [Complexity: Medium]

**Goal**: [What this phase achieves]

- [ ] [Specific action item]
- [ ] [Specific action item]
      **Deliverable**: [Tangible outcome]
      **Dependencies**: Phase 1 complete

##### Phase 3: Integration & Testing [Complexity: Medium]

...
```

### Phase 6: Write Results

```
Updating task file...
Updating frontmatter status to WIP...
Writing solution blueprint...
Writing implementation plan...
```

**Update Behavior:**

- Updates YAML `status` to `WIP`
- Updates YAML `updated_at` to current timestamp
- Replaces content of `### Solutions / Goals` section entirely
- Preserves all other content (Background, Requirements / Objectives, References)

## Examples

### Example 1: New Feature Task

**Input (`docs/prompts/0001_add_auth.md`) - Created via `tasks create`:**

```markdown
---
name: Add User Authentication
description: Add authentication to API
status: Backlog
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 10:30:00
---

## Add User Authentication

### Background

Our API currently has no authentication. Users need secure access to protected resources.

### Requirements / Objectives

Add authentication to protect API endpoints. Users should be able to register and log in.

### Solutions / Goals

### References
```

**After running `/rd:task-run docs/prompts/0001_add_auth.md`:**

````markdown
---
name: Add User Authentication
description: Implement JWT-based authentication for REST API with login, register, and protected endpoints
status: WIP
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 12:45:00
---

## Add User Authentication

### Background

Our API currently has no authentication. Users need secure access to protected resources.

### Requirements / Objectives

Add JWT-based authentication to REST API endpoints:

- POST /auth/login - validate credentials, issue JWT
- POST /auth/register - create user, issue JWT
- Protected endpoints require valid JWT in Authorization header
- Token expires after 24 hours
- Refresh token mechanism for renewal

### Solutions / Goals

#### Architecture Overview

Implement JWT-based stateless authentication:

- Login endpoint validates credentials (bcrypt), issues JWT
- Protected endpoints validate JWT via middleware
- 24-hour token expiration with refresh mechanism
- Refresh tokens stored in HTTP-only cookies

#### Core Components

- **AuthService**: Handles password hashing (bcrypt), JWT generation/validation
- **AuthMiddleware**: Express middleware for protected routes
- **TokenRefreshService**: Handles refresh token rotation

#### Data Model

```sql
users:
  - id: UUID, primary key
  - email: VARCHAR(255), unique, indexed
  - password_hash: VARCHAR(255), bcrypt
  - created_at: TIMESTAMP
  - last_login: TIMESTAMP
```
````

#### API Design

- `POST /auth/login` - {email, password} → {access_token, refresh_token}
- `POST /auth/register` - {email, password} → {access_token, refresh_token}
- `POST /auth/refresh` - {refresh_token} → {access_token}
- Protected routes: `Authorization: Bearer <token>` header required

#### Key Implementation Details

- Use `jsonwebtoken` for JWT creation/validation
- Store passwords with bcrypt (12 rounds)
- Refresh tokens stored in HTTP-only cookies
- Rate limiting on auth endpoints (10 req/min)

#### Edge Cases Handled

- Invalid credentials: Return 401 with generic error message
- Expired token: Return 401, client should use refresh endpoint
- Concurrent logins: Last login wins, previous tokens invalidated
- Password reset: Separate flow, invalidates all tokens

#### Implementation Plan

##### Phase 1: Setup & Models [Complexity: Low]

**Goal**: Database schema and password utilities

- [ ] Create users table migration
- [ ] Create User model with password hashing methods
- [ ] Add environment variables (JWT_SECRET, TOKEN_EXPIRY)
      **Deliverable**: Working User model, database updated

##### Phase 2: Auth Service [Complexity: Medium]

**Goal**: Core authentication logic

- [ ] Implement AuthService.login() with credential validation
- [ ] Implement AuthService.register() with password hashing
- [ ] Implement AuthService.generateToken() and validateToken()
- [ ] Add unit tests for AuthService
      **Deliverable**: AuthService with 80%+ test coverage
      **Dependencies**: Phase 1 complete

##### Phase 3: API Endpoints [Complexity: Medium]

**Goal**: Authentication routes

- [ ] Create POST /auth/login endpoint
- [ ] Create POST /auth/register endpoint
- [ ] Create POST /auth/refresh endpoint
- [ ] Add input validation middleware
- [ ] Add rate limiting
      **Deliverable**: Working auth endpoints
      **Dependencies**: Phase 2 complete

##### Phase 4: Middleware & Protection [Complexity: Low]

**Goal**: Route protection

- [ ] Create AuthMiddleware for JWT validation
- [ ] Apply middleware to protected routes
- [ ] Add current user to request object
      **Deliverable**: Protected API endpoints
      **Dependencies**: Phase 3 complete

##### Phase 5: Testing & Documentation [Complexity: Medium]

**Goal**: Quality assurance

- [ ] Integration tests for auth flow
- [ ] Test expired token handling
- [ ] Document API endpoints in OpenAPI spec
- [ ] Create usage examples
      **Deliverable**: Tested, documented auth system
      **Dependencies**: Phase 4 complete

### References

````

### Example 2: Bug Fix Task

**Input:**
```markdown
---
name: Fix Memory Leak
description: Memory usage grows during long jobs
status: Todo
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 10:30:00
---

## Fix Memory Leak

### Background
Memory usage grows continuously during long-running data processing jobs.

### Requirements / Objectives
Find and fix the memory leak in the data processor.

### Solutions / Goals

### References
````

**Output includes:**

- Solution: Identified event listener not being cleaned up
- Plan: Add cleanup handler, add tests, verify with load testing

### Example 3: Refactoring Task

**Input:**

```markdown
---
name: Extract Payment Processing
description: Payment logic scattered in controllers
status: Todo
---

## Extract Payment Processing

### Background

Payment logic is scattered across multiple controllers, making changes difficult.

### Requirements / Objectives

Extract to dedicated service layer for better maintainability.

### Solutions / Goals

### References

- STRIPE_API_DOCS
```

**Output includes:**

- Solution: Design PaymentService with clear interface
- Plan: Create service, migrate controllers one-by-one, add tests

## Dry Run Mode

Use `--dry-run` to preview changes without modifying files:

```bash
/rd:task-run docs/prompts/0001_feature.md --dry-run
```

**Output:**

```
=== DRY RUN: task-run ===

Task File: docs/prompts/0001_feature.md

=== FRONTMATTER UPDATES ===
status: Backlog → WIP
updated_at: 2025-01-15 10:30:00 → 2025-01-15 12:45:00
description: [may be refined]

=== REFINED REQUIREMENTS ===
[Shows refined requirements if applicable]

=== SOLUTION BLUEPRINT ===
[Shows solution that would be written to ### Solutions / Goals]

=== IMPLEMENTATION PLAN ===
[Shows plan that would be appended]

=== SUMMARY ===
Status: WIP
Phases: 5
Steps: 23

Run without --dry-run to apply changes.
```

## Interactive Features

### Confirmation Prompts

Claude will ask for confirmation when:

- Existing `### Solutions / Goals` content will be overwritten
- YAML frontmatter `status` will be changed
- Major restructuring is needed

### Clarification Questions

Claude may ask:

- "Should solution include X approach or Y approach?"
- "Is Z constraint applicable to this task?"
- "Should I prioritize speed or quality in the plan?"
- "Should I update the task description in frontmatter?"

## Status Messages

**Success:**

```
✅ Task analysis complete

File: docs/prompts/0001_add_auth.md
Status updated: Backlog → WIP
Sections updated: Solutions / Goals
Phases: 5
Steps: 23

Next Steps:
1. Review the solution blueprint
2. Adjust implementation plan if needed
3. Start with Phase 1 when ready
4. Use 'tasks update 0001 WIP' to track progress
```

**Warnings:**

```
⚠️ Solutions / Goals section already exists
Content will be overwritten. Confirm to proceed.
```

## Integration with tasks command

### Typical Workflow

```bash
# 1. Create a new task
tasks create "Add User Authentication"
# Creates: docs/prompts/0001_Add_User_Authentication.md

# 2. Edit the file to add details
# Edit Background, Requirements / Objectives, References

# 3. Run task-run to generate solution and plan
/rd:task-run docs/prompts/0001_Add_User_Authentication.md

# 4. Review the output
glow docs/prompts/0001_Add_User_Authentication.md

# 5. Start implementation
# Work through the phases in Implementation Plan

# 6. Update status as you progress
tasks update 0001 WIP     # Work in progress
tasks update 0001 Testing # In testing
tasks update 0001 Done    # Complete

# 7. Refresh kanban board anytime
tasks refresh
# or
tasks list
```

### Managing Tasks

```bash
# List all tasks
tasks list

# List tasks in specific stage
tasks list Todo
tasks list WIP

# Update task status
tasks update 0001 WIP
tasks update 0001 Testing
tasks update 0001 Done
```

## Best Practices

### Writing Task Files

1. **Fill in Background** - Provide context for why this task exists
2. **Be Specific in Requirements** - "Add authentication" vs "Add JWT auth to REST API"
3. **Add References** - Link to related docs, issues, or dependencies
4. **Define Acceptance Criteria** in Requirements / Objectives - Clear "done" criteria prevent scope creep

### Reviewing Solutions

After running, review the solution blueprint for:

- [ ] All requirements addressed
- [ ] Technical approach sound for your codebase
- [ ] Edge cases considered
- [ ] Security implications noted

### Adjusting Plans

The implementation plan is a starting point. Adjust for:

- Team size and skills
- Available time
- Existing codebase patterns
- Deployment constraints

## Troubleshooting

| Issue                        | Solution                                            |
| ---------------------------- | --------------------------------------------------- |
| "File not found"             | Use `tasks create <name>` to create task file first |
| "Missing YAML frontmatter"   | Ensure file was created via `tasks create`          |
| "Missing required sections"  | Add Background and Requirements / Objectives        |
| "Solution seems too generic" | Add more details to Background and Requirements     |
| "Plan has too many steps"    | Use `--scope minimal` for simpler plan              |

## Template Reference

The default template created by `tasks create`:

```markdown
---
name: { { PROMPT_NAME } }
description: <prompt description>
status: Backlog
created_at: { { CREATED_AT } }
updated_at: { { UPDATED_AT } }
---

## {{PROMPT_NAME}}

### Background

[Context, why this task exists]

### Requirements / Objectives

[What needs to be accomplished]

### Solutions / Goals

[Populated by task-run]

### References

[Related docs, links]
```

## See Also

- **Task Creation**: `tasks create <name>` - Create new task files
- **Task Management**: `tasks list`, `tasks update <WBS> <stage>`
- **Kanban Board**: `tasks refresh` - Update the kanban visualization
- **Skills**: `/rd:skill-add` - Convert a task into a reusable skill
- **Workflow**: `/rd:10-dev-apply` - Use 10-stage workflow for implementation
