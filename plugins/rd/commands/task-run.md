---
description: Analyze a task, design a solution blueprint, and create a detailed implementation plan.
---

# task-run

Transform a raw task description into a structured blueprint with a concrete implementation plan.

**Note:** This command works with task files created by `tasks create <name>` and follows the template structure defined in `docs/prompts/.template.md`.

## Purpose

This command provides a systematic approach to task execution:

1. **Task Analysis & Refinement** - Parse, validate, and improve the task definition
2. **Solution Design** - Create a precise, concise solution blueprint
3. **Implementation Planning** - Generate a step-by-step execution plan

The output is written back to the task file, creating a self-documenting artifact that serves as the single source of truth for the task.

## Usage

```bash
# Run with a task file
/rd:task-run <task-file.md>

# Run with analysis only (no modifications)
/rd:task-run <task-file.md> --dry-run

# Skip task refinement phase
/rd:task-run <task-file.md> --no-refine

# Specify planning scope
/rd:task-run <task-file.md> --scope <minimal|standard|comprehensive>
```

## Arguments

- `<task-file.md>` (required): Path to the task file to process
  - Can be relative: `docs/prompts/0001_feature_auth.md`
  - Can be absolute: `/Users/robin/projects/cc-agents/docs/prompts/0001_feature_auth.md`
  - Files are typically created via `prompts create <name>` command

## Options

- `--dry-run`: Analyze and display output without modifying the file
- `--no-refine`: Skip task refinement, use as-is
- `--scope <level>`: Planning depth (default: standard)
- `--plan-only`: Skip solution design, only create implementation plan

## Task File Format

### Input Format (from `prompts create`)

Task files generated by `prompts.sh` follow this structure:

```markdown
---
name: Add User Authentication
description: Implement JWT-based authentication for REST API
status: Backlog
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 10:30:00
---

## Add User Authentication

### Background

[Context, why this task exists, current situation]

### Requirements / Objectives

[What needs to be accomplished]

### Solutions / Goals

[Leave empty - will be populated by task-run]

### References

[Related docs, links, dependencies]
```

### Output Format

After execution, the file is updated with populated sections:

```markdown
---
name: Add User Authentication
description: Implement JWT-based authentication for REST API
status: WIP
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 12:45:00
---

## Add User Authentication

### Background

[Context information - may be refined]

### Requirements / Objectives

[Requirements - may be refined and expanded]

### Solutions / Goals

### Architecture Overview

...

### Core Components

...

### Data Model

...

### API / Interface Design

...

### Key Implementation Details

...

### Edge Cases Handled

...

### Implementation Plan

### Phase 1: Foundation [Complexity: Low]

...
```

### Updating Status

The command also updates the YAML frontmatter:

- `status`: Changes to `WIP` when planning begins
- `updated_at`: Updates to current timestamp
- `description`: May be refined for clarity

## Workflow

### Phase 1: Load & Validate

```
Reading task file: docs/prompts/0001_feature_auth.md
Parsing YAML frontmatter...
Validating required sections...
```

**Validation Checks:**

- [ ] File exists (use `prompts create <name>` if not)
- [ ] Valid YAML frontmatter (name, status, created_at, updated_at)
- [ ] Required sections present (Background, Requirements / Objectives)
- [ ] No conflicting requirements

**If validation fails:**

- Suggest using `prompts create <name>` for new tasks
- Prompt for missing information
- Ask user to confirm before proceeding

### Phase 2: Analyze & Refine (unless `--no-refine`)

```
Analyzing task requirements...
Identifying ambiguities...
Checking for edge cases...
```

**Refinement Actions:**

- Clarify vague requirements
- Identify implicit assumptions
- Detect missing acceptance criteria
- Spot potential scope creep
- Suggest constraint additions
- May update `description` in frontmatter for clarity

**Example refinement:**

```
BEFORE: "Add authentication to the API"

AFTER: "Add JWT-based authentication to REST API endpoints:
- POST /auth/login - returns JWT token
- POST /auth/register - creates user, returns token
- Protected endpoints require valid JWT in Authorization header
- Token expires after 24 hours
- Refresh token endpoint for renewal"
```

### Phase 3: Design Solution Blueprint

```
Designing solution architecture...
Identifying key components...
Defining integration points...
```

**Solution Design Principles:**

1. **Precise** - Specific technologies, patterns, and approaches
2. **Concise** - Essential details only, no fluff
3. **Actionable** - Clear enough to implement from
4. **Complete** - Covers all requirements and edge cases

**Solution Blueprint Structure (populates `### Solutions / Goals`):**

```markdown
### Solutions / Goals

#### Architecture Overview

[High-level design: components, data flow, key decisions]

#### Core Components

- **Component 1**: [Purpose, tech choice, key interfaces]
- **Component 2**: [Purpose, tech choice, key interfaces]

#### Data Model

[Entities, relationships, validation rules]

#### API / Interface Design

[Endpoints, methods, request/response formats]

#### Key Implementation Details

- [Design pattern to use]
- [Critical algorithm or approach]
- [Error handling strategy]
- [Security considerations]

#### Edge Cases Handled

- [Edge case 1]: [Solution approach]
- [Edge case 2]: [Solution approach]

#### Implementation Plan

[Continues below...]
```

### Phase 4: Create Implementation Plan

```
Breaking down into phases...
Sequencing dependent steps...
Estimating complexity...
```

**Planning Levels:**

**Minimal** (for quick tasks):

- 2-3 phases
- Direct steps
- Focus on core functionality

**Standard** (default):

- 4-6 phases
- Includes testing and documentation
- Balances speed and quality

**Comprehensive** (for complex features):

- 6+ phases
- Includes rollout, monitoring, rollback
- Production-ready approach

**Implementation Plan Structure (appended to `### Solutions / Goals`):**

```markdown
#### Implementation Plan

##### Phase 1: Foundation [Complexity: Low]

**Goal**: [What this phase achieves]

- [ ] [Specific action item]
- [ ] [Specific action item]
      **Deliverable**: [Tangible outcome]

##### Phase 2: Core Implementation [Complexity: Medium]

**Goal**: [What this phase achieves]

- [ ] [Specific action item]
- [ ] [Specific action item]
      **Deliverable**: [Tangible outcome]
      **Dependencies**: Phase 1 complete

##### Phase 3: Integration & Testing [Complexity: Medium]

...
```

### Phase 5: Write Results

```
Updating task file...
Updating frontmatter status to WIP...
Writing solution blueprint...
Writing implementation plan...
```

**Update Behavior:**

- Updates YAML `status` to `WIP`
- Updates YAML `updated_at` to current timestamp
- Replaces content of `### Solutions / Goals` section entirely
- Preserves all other content (Background, Requirements / Objectives, References)

## Examples

### Example 1: New Feature Task

**Input (`docs/prompts/0001_add_auth.md`) - Created via `prompts create`:**

```markdown
---
name: Add User Authentication
description: Add authentication to API
status: Backlog
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 10:30:00
---

## Add User Authentication

### Background

Our API currently has no authentication. Users need secure access to protected resources.

### Requirements / Objectives

Add authentication to protect API endpoints. Users should be able to register and log in.

### Solutions / Goals

### References
```

**After running `/rd:task-run docs/prompts/0001_add_auth.md`:**

````markdown
---
name: Add User Authentication
description: Implement JWT-based authentication for REST API with login, register, and protected endpoints
status: WIP
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 12:45:00
---

## Add User Authentication

### Background

Our API currently has no authentication. Users need secure access to protected resources.

### Requirements / Objectives

Add JWT-based authentication to REST API endpoints:

- POST /auth/login - validate credentials, issue JWT
- POST /auth/register - create user, issue JWT
- Protected endpoints require valid JWT in Authorization header
- Token expires after 24 hours
- Refresh token mechanism for renewal

### Solutions / Goals

#### Architecture Overview

Implement JWT-based stateless authentication:

- Login endpoint validates credentials (bcrypt), issues JWT
- Protected endpoints validate JWT via middleware
- 24-hour token expiration with refresh mechanism
- Refresh tokens stored in HTTP-only cookies

#### Core Components

- **AuthService**: Handles password hashing (bcrypt), JWT generation/validation
- **AuthMiddleware**: Express middleware for protected routes
- **TokenRefreshService**: Handles refresh token rotation

#### Data Model

```sql
users:
  - id: UUID, primary key
  - email: VARCHAR(255), unique, indexed
  - password_hash: VARCHAR(255), bcrypt
  - created_at: TIMESTAMP
  - last_login: TIMESTAMP
```
````

#### API Design

- `POST /auth/login` - {email, password} → {access_token, refresh_token}
- `POST /auth/register` - {email, password} → {access_token, refresh_token}
- `POST /auth/refresh` - {refresh_token} → {access_token}
- Protected routes: `Authorization: Bearer <token>` header required

#### Key Implementation Details

- Use `jsonwebtoken` for JWT creation/validation
- Store passwords with bcrypt (12 rounds)
- Refresh tokens stored in HTTP-only cookies
- Rate limiting on auth endpoints (10 req/min)

#### Edge Cases Handled

- Invalid credentials: Return 401 with generic error message
- Expired token: Return 401, client should use refresh endpoint
- Concurrent logins: Last login wins, previous tokens invalidated
- Password reset: Separate flow, invalidates all tokens

#### Implementation Plan

##### Phase 1: Setup & Models [Complexity: Low]

**Goal**: Database schema and password utilities

- [ ] Create users table migration
- [ ] Create User model with password hashing methods
- [ ] Add environment variables (JWT_SECRET, TOKEN_EXPIRY)
      **Deliverable**: Working User model, database updated

##### Phase 2: Auth Service [Complexity: Medium]

**Goal**: Core authentication logic

- [ ] Implement AuthService.login() with credential validation
- [ ] Implement AuthService.register() with password hashing
- [ ] Implement AuthService.generateToken() and validateToken()
- [ ] Add unit tests for AuthService
      **Deliverable**: AuthService with 80%+ test coverage
      **Dependencies**: Phase 1 complete

##### Phase 3: API Endpoints [Complexity: Medium]

**Goal**: Authentication routes

- [ ] Create POST /auth/login endpoint
- [ ] Create POST /auth/register endpoint
- [ ] Create POST /auth/refresh endpoint
- [ ] Add input validation middleware
- [ ] Add rate limiting
      **Deliverable**: Working auth endpoints
      **Dependencies**: Phase 2 complete

##### Phase 4: Middleware & Protection [Complexity: Low]

**Goal**: Route protection

- [ ] Create AuthMiddleware for JWT validation
- [ ] Apply middleware to protected routes
- [ ] Add current user to request object
      **Deliverable**: Protected API endpoints
      **Dependencies**: Phase 3 complete

##### Phase 5: Testing & Documentation [Complexity: Medium]

**Goal**: Quality assurance

- [ ] Integration tests for auth flow
- [ ] Test expired token handling
- [ ] Document API endpoints in OpenAPI spec
- [ ] Create usage examples
      **Deliverable**: Tested, documented auth system
      **Dependencies**: Phase 4 complete

### References

````

### Example 2: Bug Fix Task

**Input:**
```markdown
---
name: Fix Memory Leak
description: Memory usage grows during long jobs
status: Todo
created_at: 2025-01-15 10:30:00
updated_at: 2025-01-15 10:30:00
---

## Fix Memory Leak

### Background
Memory usage grows continuously during long-running data processing jobs.

### Requirements / Objectives
Find and fix the memory leak in the data processor.

### Solutions / Goals

### References
````

**Output includes:**

- Solution: Identified event listener not being cleaned up
- Plan: Add cleanup handler, add tests, verify with load testing

### Example 3: Refactoring Task

**Input:**

```markdown
---
name: Extract Payment Processing
description: Payment logic scattered in controllers
status: Todo
---

## Extract Payment Processing

### Background

Payment logic is scattered across multiple controllers, making changes difficult.

### Requirements / Objectives

Extract to dedicated service layer for better maintainability.

### Solutions / Goals

### References

- STRIPE_API_DOCS
```

**Output includes:**

- Solution: Design PaymentService with clear interface
- Plan: Create service, migrate controllers one-by-one, add tests

## Dry Run Mode

Use `--dry-run` to preview changes without modifying files:

```bash
/rd:task-run docs/prompts/0001_feature.md --dry-run
```

**Output:**

```
=== DRY RUN: task-run ===

Task File: docs/prompts/0001_feature.md

=== FRONTMATTER UPDATES ===
status: Backlog → WIP
updated_at: 2025-01-15 10:30:00 → 2025-01-15 12:45:00
description: [may be refined]

=== REFINED REQUIREMENTS ===
[Shows refined requirements if applicable]

=== SOLUTION BLUEPRINT ===
[Shows solution that would be written to ### Solutions / Goals]

=== IMPLEMENTATION PLAN ===
[Shows plan that would be appended]

=== SUMMARY ===
Status: WIP
Phases: 5
Steps: 23

Run without --dry-run to apply changes.
```

## Interactive Features

### Confirmation Prompts

Claude will ask for confirmation when:

- Existing `### Solutions / Goals` content will be overwritten
- YAML frontmatter `status` will be changed
- Major restructuring is needed

### Clarification Questions

Claude may ask:

- "Should solution include X approach or Y approach?"
- "Is Z constraint applicable to this task?"
- "Should I prioritize speed or quality in the plan?"
- "Should I update the task description in frontmatter?"

## Status Messages

**Success:**

```
✅ Task analysis complete

File: docs/prompts/0001_add_auth.md
Status updated: Backlog → WIP
Sections updated: Solutions / Goals
Phases: 5
Steps: 23

Next Steps:
1. Review the solution blueprint
2. Adjust implementation plan if needed
3. Start with Phase 1 when ready
4. Use 'prompts update 0001 WIP' to track progress
```

**Warnings:**

```
⚠️ Solutions / Goals section already exists
Content will be overwritten. Confirm to proceed.
```

## Integration with prompts.sh

### Typical Workflow

```bash
# 1. Create a new task
prompts create "Add User Authentication"
# Creates: docs/prompts/0001_Add_User_Authentication.md

# 2. Edit the file to add details
# Edit Background, Requirements / Objectives, References

# 3. Run task-run to generate solution and plan
/rd:task-run docs/prompts/0001_Add_User_Authentication.md

# 4. Review the output
glow docs/prompts/0001_Add_User_Authentication.md

# 5. Start implementation
# Work through the phases in Implementation Plan

# 6. Update status as you progress
prompts update 0001 WIP     # Work in progress
prompts update 0001 Testing # In testing
prompts update 0001 Done    # Complete

# 7. Refresh kanban board anytime
prompts refresh
# or
prompts list
```

### Managing Tasks

```bash
# List all tasks
prompts list

# List tasks in specific stage
prompts list Todo
prompts list WIP

# Update task status
prompts update 0001 WIP
prompts update 0001 Testing
prompts update 0001 Done
```

## Best Practices

### Writing Task Files

1. **Fill in Background** - Provide context for why this task exists
2. **Be Specific in Requirements** - "Add authentication" vs "Add JWT auth to REST API"
3. **Add References** - Link to related docs, issues, or dependencies
4. **Define Acceptance Criteria** in Requirements / Objectives - Clear "done" criteria prevent scope creep

### Reviewing Solutions

After running, review the solution blueprint for:

- [ ] All requirements addressed
- [ ] Technical approach sound for your codebase
- [ ] Edge cases considered
- [ ] Security implications noted

### Adjusting Plans

The implementation plan is a starting point. Adjust for:

- Team size and skills
- Available time
- Existing codebase patterns
- Deployment constraints

## Troubleshooting

| Issue                        | Solution                                              |
| ---------------------------- | ----------------------------------------------------- |
| "File not found"             | Use `prompts create <name>` to create task file first |
| "Missing YAML frontmatter"   | Ensure file was created via `prompts create`          |
| "Missing required sections"  | Add Background and Requirements / Objectives          |
| "Solution seems too generic" | Add more details to Background and Requirements       |
| "Plan has too many steps"    | Use `--scope minimal` for simpler plan                |

## Template Reference

The default template created by `prompts create`:

```markdown
---
name: { { PROMPT_NAME } }
description: <prompt description>
status: Backlog
created_at: { { CREATED_AT } }
updated_at: { { UPDATED_AT } }
---

## {{PROMPT_NAME}}

### Background

[Context, why this task exists]

### Requirements / Objectives

[What needs to be accomplished]

### Solutions / Goals

[Populated by task-run]

### References

[Related docs, links]
```

## See Also

- **Task Creation**: `prompts create <name>` - Create new task files
- **Task Management**: `prompts list`, `prompts update <WBS> <stage>`
- **Kanban Board**: `prompts refresh` - Update the kanban visualization
- **Skills**: `/rd:skill-add` - Convert a task into a reusable skill
- **Workflow**: `/rd:10-dev-apply` - Use 10-stage workflow for implementation
