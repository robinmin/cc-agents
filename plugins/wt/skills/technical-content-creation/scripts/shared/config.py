#!/usr/bin/env python3
"""
Configuration utilities for technical-content-creation skill.

Handles loading and saving configuration from ~/.claude/wt/config.jsonc
with JSONC (JSON with Comments) support.

Security: Uses json-comment library for safe JSONC parsing instead of regex.
"""

import json
from pathlib import Path
from typing import Any, Optional
from datetime import datetime

# Try to import json-comment library, fall back to safe regex parsing
# Note: The package is 'jsoncomment' and exports 'JsonComment'
try:
    from jsoncomment import JsonComment
    HAS_JSON_COMMENT = True
except ImportError:
    HAS_JSON_COMMENT = False


class WTConfigPath:
    """Paths for wt plugin configuration."""

    CONFIG_DIR = Path.home() / ".claude" / "wt"
    CONFIG_FILE = CONFIG_DIR / "config.jsonc"
    TCC_SECTION = "technical-content-creation"


def load_jsonc(file_path: Path) -> dict[str, Any]:
    """
    Load JSONC file and parse as JSON.

    Uses json-comment library if available for safe parsing.
    Falls back to internal regex-based parsing if library not installed.

    Args:
        file_path: Path to JSONC file

    Returns:
        Parsed dictionary

    Raises:
        FileNotFoundError: If file doesn't exist
        json.JSONDecodeError: If file is not valid JSONC
    """
    if not file_path.exists():
        raise FileNotFoundError(f"Config file not found: {file_path}")

    content = file_path.read_text(encoding='utf-8')

    if HAS_JSON_COMMENT:
        # Use json-comment library for safe parsing
        jc = JsonComment()
        try:
            return jc.loads(content)
        except Exception as e:
            raise json.JSONDecodeError(
                f"Invalid JSONC in {file_path}: {str(e)}",
                content,
                0
            )
    else:
        # Fallback: use standard JSON module (comments will cause error)
        # This is intentional - we want proper JSONC parsing, not fragile regex
        try:
            return json.loads(content)
        except json.JSONDecodeError as e:
            raise json.JSONDecodeError(
                f"JSON with comments detected but json-comment library not installed. "
                f"Install it with: pip install json-comment. Error: {e.msg}",
                e.doc,
                e.pos
            )


def save_jsonc(data: dict[str, Any], file_path: Path, pretty: bool = True) -> None:
    """
    Save dictionary as JSONC file.

    Args:
        data: Dictionary to save
        file_path: Target file path
        pretty: Whether to format with indentation
    """
    # Create parent directory if needed
    file_path.parent.mkdir(parents=True, exist_ok=True)

    # Write with proper formatting
    indent = 2 if pretty else None
    json_str = json.dumps(data, indent=indent, ensure_ascii=False)

    # Add file header comment if new file
    if not file_path.exists() or file_path.stat().st_size == 0:
        header = (
            "// wt Plugin Configuration\n"
            "// Auto-generated by technical-content-creation skill\n"
            "// Last updated: " + datetime.now().isoformat() + "\n\n"
        )
        json_str = header + json_str

    file_path.write_text(json_str, encoding='utf-8')


def ensure_config_exists() -> None:
    """Create config directory and file if they don't exist."""
    WTConfigPath.CONFIG_DIR.mkdir(parents=True, exist_ok=True)

    if not WTConfigPath.CONFIG_FILE.exists():
        # Create default config
        default_config = {
            "version": "1.0.0",
            "last_updated": datetime.now().isoformat(),
            WTConfigPath.TCC_SECTION: {
                "tcc_repo_root": None,
                "default_collection": None,
                "auto_create_collections": True,
                "collections_path": "collections",
            }
        }
        save_jsonc(default_config, WTConfigPath.CONFIG_FILE)


def get_wt_config() -> dict[str, Any]:
    """
    Load the entire wt configuration.

    Returns:
        Configuration dictionary. Returns empty dict if config doesn't exist.

    Raises:
        json.JSONDecodeError: If config file is malformed
    """
    try:
        ensure_config_exists()
        return load_jsonc(WTConfigPath.CONFIG_FILE)
    except FileNotFoundError:
        return {}
    except json.JSONDecodeError as e:
        raise json.JSONDecodeError(
            f"Invalid JSONC in {WTConfigPath.CONFIG_FILE}: {e.msg}",
            e.doc,
            e.pos
        )


def get_tcc_config() -> dict[str, Any]:
    """
    Get the technical-content-creation section from wt config.

    Returns:
        TCC configuration dictionary. Returns defaults if section doesn't exist.

    Example:
        {
            "tcc_repo_root": "/path/to/repo",
            "default_collection": "technical-tutorials",
            "auto_create_collections": True,
            "collections_path": "collections",
        }
    """
    config = get_wt_config()

    # Get TCC section or create default
    tcc_config = config.get(WTConfigPath.TCC_SECTION, {})

    # Ensure all required keys exist
    defaults = {
        "tcc_repo_root": None,
        "default_collection": None,
        "auto_create_collections": True,
        "collections_path": "collections",
    }

    for key, value in defaults.items():
        if key not in tcc_config:
            tcc_config[key] = value

    return tcc_config


def set_tcc_config(key: str, value: Any) -> None:
    """
    Update a specific key in the TCC configuration.

    Supported keys:
    - tcc_repo_root: Path to the TCC repository
    - default_collection: Default collection name
    - auto_create_collections: Whether to auto-create collections
    - collections_path: Relative path to collections directory

    Args:
        key: Configuration key name
        value: New value for the key

    Raises:
        ValueError: If key is not a valid TCC config key
    """
    valid_keys = {
        "tcc_repo_root",
        "default_collection",
        "auto_create_collections",
        "collections_path",
    }

    if key not in valid_keys:
        raise ValueError(
            f"Invalid TCC config key: {key}. "
            f"Valid keys are: {', '.join(sorted(valid_keys))}"
        )

    # Load current config
    config = get_wt_config()

    # Ensure TCC section exists
    if WTConfigPath.TCC_SECTION not in config:
        config[WTConfigPath.TCC_SECTION] = {}

    # Update the key
    config[WTConfigPath.TCC_SECTION][key] = value
    config[WTConfigPath.TCC_SECTION]["last_updated"] = datetime.now().isoformat()

    # Save back to file
    save_jsonc(config, WTConfigPath.CONFIG_FILE)


def get_tcc_repo_root() -> Optional[Path]:
    """
    Get the TCC repository root path from config.

    Returns:
        Path object if configured, None otherwise
    """
    tcc_config = get_tcc_config()
    root = tcc_config.get("tcc_repo_root")
    return Path(root) if root else None


def set_tcc_repo_root(path: str) -> None:
    """
    Set the TCC repository root path.

    Args:
        path: Absolute path to the repository root
    """
    # Convert to absolute path
    root_path = Path(path).expanduser().resolve()

    # Validate path exists
    if not root_path.exists():
        raise FileNotFoundError(
            f"Repository root does not exist: {root_path}"
        )

    set_tcc_config("tcc_repo_root", str(root_path))


# CLI convenience functions
def print_config() -> None:
    """Print current TCC configuration."""
    tcc_config = get_tcc_config()
    print("Technical Content Creation Configuration:")
    print(f"  Repo Root: {tcc_config.get('tcc_repo_root') or 'Not set'}")
    print(f"  Default Collection: {tcc_config.get('default_collection') or 'Not set'}")
    print(f"  Auto-create Collections: {tcc_config.get('auto_create_collections')}")
    print(f"  Collections Path: {tcc_config.get('collections_path')}")


if __name__ == "__main__":
    # CLI for testing
    import sys
    if len(sys.argv) > 1:
        if sys.argv[1] == "get":
            print_config()
        elif sys.argv[1] == "set" and len(sys.argv) == 4:
            set_tcc_config(sys.argv[2], sys.argv[3])
            print(f"Updated: {sys.argv[2]} = {sys.argv[3]}")
        else:
            print("Usage: python config.py [get|set KEY VALUE]")
    else:
        print_config()
